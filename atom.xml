<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LUOXIAO&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="luoxiao.cf/"/>
  <updated>2019-11-13T04:56:08.680Z</updated>
  <id>luoxiao.cf/</id>
  
  <author>
    <name>Luoxiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>神经网络：基本分类[转]</title>
    <link href="luoxiao.cf/2019/08/20/2019%E2%80%9308-20-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%5B%E8%BD%AC%5D/"/>
    <id>luoxiao.cf/2019/08/20/2019–08-20-神经网络：基本分类[转]/</id>
    <published>2019-08-20T22:39:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:55 GMT+0000 (Coordinated Universal Time) --><p>代码式例：<a href="https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/keras/basic_classification.ipynb" target="_blank" rel="noopener">Run in Gogle Colab</a> / <a href="https://github.com/tensorflow/docs/blob/master/site/en/tutorials/keras/basic_classification.ipynb" target="_blank" rel="noopener">View source on Github</a></p><p>本指南转自TensorFlow官网。主要训练了一个神经网络模型，来对服装图像进行分类，例如运动鞋和衬衫。如果您不了解所有细节也不需要担心，这是一个对完整TensorFlow项目的简要概述，相关的细节会在需要时进行解释</p><p>本指南使用<code>tf.keras</code>，这是一个用于在TensorFlow中构建和训练模型的高级API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function, unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入TensorFlow和tf.keras</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入辅助库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.0</span><span class="number">.0</span>-beta1</span><br></pre></td></tr></table></figure><h3 id="导入fashion-mnist数据集"><a class="markdownIt-Anchor" href="#导入fashion-mnist数据集"></a> 导入Fashion MNIST数据集</h3><p>本指南使用Fashion MNIST 数据集，其中包含了10个类别中共70,000张灰度图像。图像包含了低分辨率（28 x 28像素）的单个服装物品，如下所示:<br><img src="https://i.loli.net/2019/08/20/jmXkbzvKDIF9fid.png" alt="Figure 1. Fashion-MNIST samples (by Zalando, MIT License)."></p><p>Fashion MNIST 旨在替代传统的MNIST数据集 — 它经常被作为机器学习在计算机视觉方向的&quot;Hello, World&quot;。MNIST数据集包含手写数字（0,1,2等）的图像，其格式与我们在此处使用的服装相同。</p><p>本指南使用Fashion MNIST进行多样化，因为它比普通的MNIST更具挑战性。两个数据集都相对较小，用于验证算法是否按预期工作。它们是测试和调试代码的良好起点。</p><p>我们将使用60,000张图像来训练网络和10,000张图像来评估网络模型学习图像分类任务的准确程度。您可以直接从TensorFlow使用Fashion MNIST，只需导入并加载数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Downloading data <span class="keyword">from</span> https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-labels-idx1-ubyte.gz</span><br><span class="line"><span class="number">32768</span>/<span class="number">29515</span> [=================================] - <span class="number">0</span>s <span class="number">0</span>us/step</span><br><span class="line">Downloading data <span class="keyword">from</span> https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-images-idx3-ubyte.gz</span><br><span class="line"><span class="number">26427392</span>/<span class="number">26421880</span> [==============================] - <span class="number">0</span>s <span class="number">0</span>us/step</span><br><span class="line">Downloading data <span class="keyword">from</span> https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-labels-idx1-ubyte.gz</span><br><span class="line"><span class="number">8192</span>/<span class="number">5148</span> [===============================================] - <span class="number">0</span>s <span class="number">0</span>us/step</span><br><span class="line">Downloading data <span class="keyword">from</span> https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-images-idx3-ubyte.gz</span><br><span class="line"><span class="number">4423680</span>/<span class="number">4422102</span> [==============================] - <span class="number">0</span>s <span class="number">0</span>us/step</span><br></pre></td></tr></table></figure><p>加载数据集并返回四个NumPy数组:</p><ul><li>train_images和train_labels数组是训练集—这是模型用来学习的数据。</li><li>模型通过测试集进行测试, 即test_images与 test_labels两个数组。</li></ul><p>图像是28x28 NumPy数组，像素值介于0到255之间。labels是一个整数数组，数值介于0到9之间。这对应了图像所代表的服装的类别:</p><table><thead><tr><th>标签</th><th>类别</th></tr></thead><tbody><tr><td>0</td><td>T-shirt/top</td></tr><tr><td>1</td><td>Trouser</td></tr><tr><td>2</td><td>Pullover</td></tr><tr><td>3</td><td>Dress</td></tr><tr><td>4</td><td>Coat</td></tr><tr><td>5</td><td>Sandal</td></tr><tr><td>6</td><td>Shirt</td></tr><tr><td>7</td><td>Sneaker</td></tr><tr><td>8</td><td>Bag</td></tr><tr><td>9</td><td>Ankle boot</td></tr></tbody></table><p>每个图像都映射到一个标签。由于类别名称不包含在数据集中,因此把他们存储在这里以便在绘制图像时使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_names = [<span class="string">'T-shirt/top'</span>, <span class="string">'Trouser'</span>, <span class="string">'Pullover'</span>, <span class="string">'Dress'</span>, <span class="string">'Coat'</span>,<span class="string">'Sandal'</span>, <span class="string">'Shirt'</span>, <span class="string">'Sneaker'</span>, <span class="string">'Bag'</span>, <span class="string">'Ankle boot'</span>]</span><br></pre></td></tr></table></figure><h3 id="探索数据"><a class="markdownIt-Anchor" href="#探索数据"></a> 探索数据</h3><p>让我们在训练模型之前探索数据集的格式。以下显示训练集中有60,000个图像，每个图像表示为28 x 28像素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_images.shape</span><br></pre></td></tr></table></figure><p>同样，训练集中有60,000个标签:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(train_labels)</span><br></pre></td></tr></table></figure><p>每个标签都是0到9之间的整数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_labels</span><br></pre></td></tr></table></figure><p>测试集中有10,000个图像。 同样，每个图像表示为28×28像素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_images.shape</span><br></pre></td></tr></table></figure><p>测试集包含10,000个图像标签:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(test_labels)</span><br></pre></td></tr></table></figure><h3 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h3><p>在训练网络之前必须对数据进行预处理。 如果您检查训练集中的第一个图像，您将看到像素值落在0到255的范围内:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.grid(<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/baylZYDAmQNUT4L.png" alt="2.png"></p><p>在馈送到神经网络模型之前，我们将这些值缩放到0到1的范围。为此，我们将像素值值除以255。重要的是，对训练集和测试集要以相同的方式进行预处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_images = train_images / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">test_images = test_images / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><p>显示训练集中的前25个图像，并在每个图像下方显示类名。验证数据格式是否正确，我们是否已准备好构建和训练网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    plt.subplot(<span class="number">5</span>,<span class="number">5</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.grid(<span class="literal">False</span>)</span><br><span class="line">    plt.imshow(train_images[i], cmap=plt.cm.binary)</span><br><span class="line">    plt.xlabel(class_names[train_labels[i]])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/kXFbnSYayO19lpZ.png" alt="3.png"></p><h3 id="构建模型"><a class="markdownIt-Anchor" href="#构建模型"></a> 构建模型</h3><p>构建神经网络需要配置模型的层，然后编译模型。</p><p><strong>设置网络层</strong></p><p>一个神经网络最基本的组成部分便是网络层。网络层从提供给他们的数据中提取表示，并期望这些表示对当前的问题更加有意义</p><p>大多数深度学习是由串连在一起的网络层所组成。大多数网络层，例如<code>tf.keras.layers.Dense</code>，具有在训练期间学习的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = keras.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">    keras.layers.Dense(<span class="number">128</span>, activation=tf.nn.relu),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation=tf.nn.softmax)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>网络中的第一层, <code>tf.keras.layers.Flatten</code>, 将图像格式从一个二维数组(包含着28x28个像素)转换成为一个包含着28 * 28 = 784个像素的一维数组。可以将这个网络层视为它将图像中未堆叠的像素排列在一起。这个网络层没有需要学习的参数;它仅仅对数据进行格式化。</p><p>在像素被展平之后，网络由一个包含有两个tf.keras.layers.Dense网络层的序列组成。他们被称作稠密链接层或全连接层。 第一个Dense网络层包含有128个节点(或被称为神经元)。第二个(也是最后一个)网络层是一个包含10个节点的softmax层—它将返回包含10个概率分数的数组，总和为1。每个节点包含一个分数，表示当前图像属于10个类别之一的概率。</p><p><strong>编译模型</strong></p><p>在模型准备好进行训练之前，它还需要一些配置。这些是在模型的编译(compile)步骤中添加的:</p><ul><li>损失函数 —这可以衡量模型在培训过程中的准确程度。 我们希望将此函数最小化以&quot;驱使&quot;模型朝正确的方向拟合。</li><li>优化器 —这就是模型根据它看到的数据及其损失函数进行更新的方式。’</li><li>评价方式 —用于监控训练和测试步骤。以下示例使用准确率(accuracy)，即正确分类的图像的分数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a class="markdownIt-Anchor" href="#训练模型"></a> 训练模型</h3><p>训练神经网络模型需要以下步骤:</p><pre><code>1. 将训练数据提供给模型 - 在本案例中，他们是train_images和train_labels数组。2. 模型学习如何将图像与其标签关联3. 我们使用模型对测试集进行预测, 在本案例中为test_images数组。我们验证预测结果是否匹配test_labels数组中保存的标签。4. 通过调用model.fit方法来训练模型 — 模型对训练数据进行&quot;拟合&quot;。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(train_images, train_labels, epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Logging before flag parsing goes to stderr.</span><br><span class="line">W0703 <span class="number">00</span>:<span class="number">57</span>:<span class="number">16.227570</span> <span class="number">140360607328000</span> deprecation.py:<span class="number">323</span>] From /tmpfs/src/tf_docs_env/lib/python3<span class="number">.5</span>/site-packages/tensorflow/python/ops/math_grad.py:<span class="number">1250</span>: add_dispatch_support.&lt;locals&gt;.wrapper (<span class="keyword">from</span> tensorflow.python.ops.array_ops) <span class="keyword">is</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future version.</span><br><span class="line">Instructions <span class="keyword">for</span> updating:</span><br><span class="line">Use tf.where <span class="keyword">in</span> <span class="number">2.0</span>, which has the same broadcast rule <span class="keyword">as</span> np.where</span><br><span class="line"></span><br><span class="line">Train on <span class="number">60000</span> samples</span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">5</span></span><br><span class="line"><span class="number">60000</span>/<span class="number">60000</span> [==============================] - <span class="number">5</span>s <span class="number">85</span>us/sample - loss: <span class="number">0.4949</span> - accuracy: <span class="number">0.8267</span></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">5</span></span><br><span class="line"><span class="number">60000</span>/<span class="number">60000</span> [==============================] - <span class="number">6</span>s <span class="number">92</span>us/sample - loss: <span class="number">0.3753</span> - accuracy: <span class="number">0.8641</span></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">5</span></span><br><span class="line"><span class="number">60000</span>/<span class="number">60000</span> [==============================] - <span class="number">5</span>s <span class="number">89</span>us/sample - loss: <span class="number">0.3355</span> - accuracy: <span class="number">0.8784</span></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">5</span></span><br><span class="line"><span class="number">60000</span>/<span class="number">60000</span> [==============================] - <span class="number">4</span>s <span class="number">72</span>us/sample - loss: <span class="number">0.3136</span> - accuracy: <span class="number">0.8855</span></span><br><span class="line">Epoch <span class="number">5</span>/<span class="number">5</span></span><br><span class="line"><span class="number">60000</span>/<span class="number">60000</span> [==============================] - <span class="number">4</span>s <span class="number">69</span>us/sample - loss: <span class="number">0.2955</span> - accuracy: <span class="number">0.8921</span></span><br><span class="line"></span><br><span class="line">&lt;tensorflow.python.keras.callbacks.History at <span class="number">0x7fa81c2c1b38</span>&gt;</span><br></pre></td></tr></table></figure><p>随着模型训练，将显示损失和准确率等指标。该模型在训练数据上达到约0.88(或88％)的准确度。</p><h3 id="评估准确率"><a class="markdownIt-Anchor" href="#评估准确率"></a> 评估准确率</h3><p>接下来，比较模型在测试数据集上的执行情况:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_acc = model.evaluate(test_images, test_labels)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Test accuracy:'</span>, test_acc)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>/<span class="number">10000</span> [==============================] - <span class="number">1</span>s <span class="number">53</span>us/sample - loss: <span class="number">0.3489</span> - accuracy: <span class="number">0.8713</span></span><br><span class="line">Test accuracy: <span class="number">0.8713</span></span><br></pre></td></tr></table></figure><p>事实证明，测试数据集的准确性略低于训练数据集的准确性。训练精度和测试精度之间的差距是过拟合的一个例子。过拟合是指机器学习模型在新数据上的表现比在训练数据上表现更差。</p><h3 id="进行预测"><a class="markdownIt-Anchor" href="#进行预测"></a> 进行预测</h3><p>通过训练模型，我们可以使用它来预测某些图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.predict(test_images)</span><br></pre></td></tr></table></figure><p>在此，模型已经预测了测试集中每个图像的标签。我们来看看第一个预测:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predictions[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">6.6858855e-05</span>, <span class="number">2.5964803e-07</span>, <span class="number">5.3627105e-06</span>, <span class="number">4.5019146e-06</span>,</span><br><span class="line">       <span class="number">2.7420206e-06</span>, <span class="number">4.7881842e-02</span>, <span class="number">2.3233067e-04</span>, <span class="number">5.4705784e-02</span>,</span><br><span class="line">       <span class="number">8.5581087e-05</span>, <span class="number">8.9701480e-01</span>], dtype=float32)</span><br></pre></td></tr></table></figure><p>预测是10个数字的数组。这些描述了模型的&quot;信心&quot;，即图像对应于10种不同服装中的每一种。我们可以看到哪个标签具有最高的置信度值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argmax(predictions[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>9</p><p>因此，模型最有信心的是这个图像是ankle boot，或者 class_names[9]。 我们可以检查测试标签，看看这是否正确:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_labels[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>9</p><p>我们可以用图表来查看全部10个类别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_image</span><span class="params">(i, predictions_array, true_label, img)</span>:</span></span><br><span class="line">  predictions_array, true_label, img = predictions_array[i], true_label[i], img[i]</span><br><span class="line">  plt.grid(<span class="literal">False</span>)</span><br><span class="line">  plt.xticks([])</span><br><span class="line">  plt.yticks([])</span><br><span class="line">  </span><br><span class="line">  plt.imshow(img, cmap=plt.cm.binary)</span><br><span class="line">  </span><br><span class="line">  predicted_label = np.argmax(predictions_array)</span><br><span class="line">  <span class="keyword">if</span> predicted_label == true_label:</span><br><span class="line">    color = <span class="string">'blue'</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    color = <span class="string">'red'</span></span><br><span class="line">  </span><br><span class="line">  plt.xlabel(<span class="string">"&#123;&#125; &#123;:2.0f&#125;% (&#123;&#125;)"</span>.format(class_names[predicted_label],</span><br><span class="line">                                <span class="number">100</span>*np.max(predictions_array),</span><br><span class="line">                                class_names[true_label]),</span><br><span class="line">                                color=color)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_value_array</span><span class="params">(i, predictions_array, true_label)</span>:</span></span><br><span class="line">  predictions_array, true_label = predictions_array[i], true_label[i]</span><br><span class="line">  plt.grid(<span class="literal">False</span>)</span><br><span class="line">  plt.xticks([])</span><br><span class="line">  plt.yticks([])</span><br><span class="line">  thisplot = plt.bar(range(<span class="number">10</span>), predictions_array, color=<span class="string">"#777777"</span>)</span><br><span class="line">  plt.ylim([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">  predicted_label = np.argmax(predictions_array)</span><br><span class="line">  </span><br><span class="line">  thisplot[predicted_label].set_color(<span class="string">'red'</span>)</span><br><span class="line">  thisplot[true_label].set_color(<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><p>让我们看看第0个图像，预测和预测数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plot_image(i, predictions, test_labels, test_images)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plot_value_array(i, predictions,  test_labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/vJHqX6LogKsxzjW.png" alt="4.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">12</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plot_image(i, predictions, test_labels, test_images)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plot_value_array(i, predictions,  test_labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/J7YiK4uWB68bLsG.png" alt="5.png"></p><p>让我们绘制几个图像及其预测结果。正确的预测标签是蓝色的，不正确的预测标签是红色的。该数字给出了预测标签的百分比(满分100)。请注意，即使非常自信，也可能出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 绘制前X个测试图像，预测标签和真实标签</span></span><br><span class="line"><span class="comment"># 以蓝色显示正确的预测，红色显示不正确的预测</span></span><br><span class="line">num_rows = <span class="number">5</span></span><br><span class="line">num_cols = <span class="number">3</span></span><br><span class="line">num_images = num_rows*num_cols</span><br><span class="line">plt.figure(figsize=(<span class="number">2</span>*<span class="number">2</span>*num_cols, <span class="number">2</span>*num_rows))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_images):</span><br><span class="line">  plt.subplot(num_rows, <span class="number">2</span>*num_cols, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">  plot_image(i, predictions, test_labels, test_images)</span><br><span class="line">  plt.subplot(num_rows, <span class="number">2</span>*num_cols, <span class="number">2</span>*i+<span class="number">2</span>)</span><br><span class="line">  plot_value_array(i, predictions, test_labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/vN8hQ4SVILftudE.png" alt="6.png"></p><p>最后，使用训练的模型对单个图像进行预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从测试数据集中获取图像</span></span><br><span class="line">img = test_images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(img.shape)</span><br></pre></td></tr></table></figure><p>(28, 28)</p><p><code>tf.keras</code>模型经过优化，可以一次性对批量,或者一个集合的数据进行预测。因此，即使我们使用单个图像，我们也需要将其添加到列表中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将图像添加到批次中，即使它是唯一的成员。</span></span><br><span class="line">img = (np.expand_dims(img,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">print(img.shape)</span><br></pre></td></tr></table></figure><p>(1, 28, 28)</p><p>现在来预测图像:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predictions_single = model.predict(img)</span><br><span class="line"></span><br><span class="line">print(predictions_single)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">6.6858927e-05</span> <span class="number">2.5964729e-07</span> <span class="number">5.3627055e-06</span> <span class="number">4.5019060e-06</span> <span class="number">2.7420206e-06</span></span><br><span class="line">  <span class="number">4.7881793e-02</span> <span class="number">2.3233047e-04</span> <span class="number">5.4705758e-02</span> <span class="number">8.5581087e-05</span> <span class="number">8.9701480e-01</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot_value_array(<span class="number">0</span>, predictions_single, test_labels)</span><br><span class="line">plt.xticks(range(<span class="number">10</span>), class_names, rotation=<span class="number">45</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/20/aEGWf5qzSgkbAQV.png" alt="9.png"></p><p>model.predict返回一个包含列表的列表，每个图像对应一个列表的数据。获取批次中我们(仅有的)图像的预测:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prediction_result = np.argmax(predictions_single[<span class="number">0</span>])</span><br><span class="line">print(prediction_result)</span><br></pre></td></tr></table></figure><p>9</p><p>而且，和之前一样，模型预测标签为9。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:55 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;代码式例：&lt;a href=&quot;https://colab.research.google.com/github/
      
    
    </summary>
    
      <category term="机器学习" scheme="luoxiao.cf/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>HiveSQL优化</title>
    <link href="luoxiao.cf/2019/08/17/2019%E2%80%9308-17-HiveSQL%E4%BC%98%E5%8C%96/"/>
    <id>luoxiao.cf/2019/08/17/2019–08-17-HiveSQL优化/</id>
    <published>2019-08-17T21:54:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>下面列举一些常用的SQL优化方案</p><h2 id="sql引起的数据倾斜"><a class="markdownIt-Anchor" href="#sql引起的数据倾斜"></a> sql引起的数据倾斜</h2><p>数据倾斜会导致某个Reduce运行过慢影响到整体的运行时长。通常在join和group by时，会出现这样的问题</p><ol><li>join引起的数据倾斜,下面操作会将一个job变为两个job执行HQL</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果是join过程出现倾斜，应该设置为<span class="literal">true</span></span></span><br><span class="line">set hive.optimize.skewjoin=true;</span><br><span class="line"><span class="meta">#</span><span class="bash">这个是join的键对应的记录条数超过这个值则会进行优化</span></span><br><span class="line">set hive.skewjoin.key=100000;</span><br></pre></td></tr></table></figure><ol start="2"><li>group by key引起的数据倾斜</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果group by过程出现倾斜应该设置为<span class="literal">true</span></span></span><br><span class="line">set hive.groupby.skewindata=true;</span><br><span class="line"><span class="meta">#</span><span class="bash">这个是group的键对应的记录条数超过这个值则会进行优化</span></span><br><span class="line">set hive.groupby.mapaggr.checkinterval=100000;</span><br></pre></td></tr></table></figure><h2 id="mapjoinmap端执行join"><a class="markdownIt-Anchor" href="#mapjoinmap端执行join"></a> mapjoin(map端执行join）</h2><p>针对应用场景合理使用MapJoin也很重要。Map Join可以解决数据倾斜问题，因为没有Reduce Task了;只运行Map Task，相比多运行Reduce Task来说省时间。</p><p>启动方式一：(自动)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.hive.auto.convert.join = true;</span><br><span class="line"><span class="meta">#</span><span class="bash">默认值是25mb小表小于25mb自动启动mapjoin </span></span><br><span class="line">hive.mapjoin.smalltable.filesize=25000000</span><br></pre></td></tr></table></figure><p>启动方式二：(手动）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+mapjoin(A)*/</span> f.a,f.b <span class="keyword">from</span> A t <span class="keyword">join</span> B f <span class="keyword">on</span> (f.a=t.a)</span><br></pre></td></tr></table></figure><h2 id="bucketjoin"><a class="markdownIt-Anchor" href="#bucketjoin"></a> bucketjoin</h2><p>合理利用桶分区很重要，因为它可以避免全表检索，在大数据场景中全表检索意味着什么应该可以想象…</p><p>在满足下面两个情况时使用：</p><ul><li>1.两个表以相同方式划分桶</li><li>2.两个表的桶个数是倍数关系</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">order</span>(cid <span class="built_in">int</span>,price <span class="built_in">float</span>) clustered <span class="keyword">by</span>(cid)   <span class="keyword">into</span> <span class="number">32</span> buckets;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">first</span> <span class="keyword">string</span>) clustered <span class="keyword">by</span>(<span class="keyword">id</span>)   <span class="keyword">into</span> <span class="number">32</span>/<span class="number">64</span> buckets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> price <span class="keyword">from</span> <span class="keyword">order</span> t <span class="keyword">join</span> customer s <span class="keyword">on</span> t.cid=s.id;</span><br></pre></td></tr></table></figure><h2 id="where条件优化"><a class="markdownIt-Anchor" href="#where条件优化"></a> where条件优化</h2><p>尽可能早的筛掉更多的数据。</p><p>优化前（关系数据库不用考虑会自动优化）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m.cid,u.id <span class="keyword">from</span> <span class="keyword">order</span> m <span class="keyword">join</span> customer u <span class="keyword">on</span> m.cid =u.id <span class="keyword">where</span> m.dt=<span class="string">'2019-08-18'</span>;</span><br></pre></td></tr></table></figure><p>优化后(where条件在map端执行而不是在reduce端执行）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m.cid,u.id <span class="keyword">from</span> （<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> dt=<span class="string">'2019-08-18'</span>） m <span class="keyword">join</span> customer u <span class="keyword">on</span> m.cid =u.id;</span><br></pre></td></tr></table></figure><h2 id="count-distinct优化"><a class="markdownIt-Anchor" href="#count-distinct优化"></a> count distinct优化</h2><p>只有一个reduce，先去重再count负担比较大;解决方案是：启动两个job，一个job负责子查询(可以有多个reduce)，另一个job负责count(1)</p><p>优化前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">id</span>) <span class="keyword">from</span> tablename;</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">id</span> <span class="keyword">from</span> tablename) tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tablename <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span>) tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> mapred.reduce.tasks=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="合理使用union-all"><a class="markdownIt-Anchor" href="#合理使用union-all"></a> 合理使用union all</h2><p>优化前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="keyword">sum</span>(b),<span class="keyword">count</span>(<span class="keyword">distinct</span> c),<span class="keyword">count</span>(<span class="keyword">distinct</span> d) <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="keyword">sum</span>(b) <span class="keyword">as</span> b,<span class="keyword">count</span>(c) <span class="keyword">as</span> c,<span class="keyword">count</span>(d) <span class="keyword">as</span> d <span class="keyword">from</span></span><br><span class="line">（</span><br><span class="line"><span class="keyword">select</span> a, <span class="number">0</span> <span class="keyword">as</span> b,c,<span class="literal">null</span> <span class="keyword">as</span> d <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> a,c</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> a,<span class="number">0</span> <span class="keyword">as</span> b, <span class="literal">null</span> <span class="keyword">as</span> c,d <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> a,d</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> a, b,<span class="literal">null</span> <span class="keyword">as</span> c ,<span class="literal">null</span> <span class="keyword">as</span> d <span class="keyword">from</span> <span class="keyword">test</span>) tmp <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;下面列举一些常用的SQL优化方案&lt;/p&gt;&lt;h2 id=&quot;sql引起的数据倾斜&quot;&gt;&lt;a class=&quot;markd
      
    
    </summary>
    
      <category term="大数据" scheme="luoxiao.cf/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>HDMI连接Raspberry</title>
    <link href="luoxiao.cf/2019/07/29/2019%E2%80%9307-29-HDMI%E8%BF%9E%E6%8E%A5Raspberry/"/>
    <id>luoxiao.cf/2019/07/29/2019–07-29-HDMI连接Raspberry/</id>
    <published>2019-07-29T22:26:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>通常情况下，树莓派会自动检测显示器的类型并修改配置。但有时，自动检测的结果可能不正确。如果你的树莓派连接到电视上但没有任何显示的话，你要考虑手动修改树莓派的显示配置了</p><p><img src="https://i.loli.net/2019/07/30/5d3f1b5a7dc4c45534.jpeg" alt="https://i.loli.net/2019/07/30/5d3f1b5a7dc4c45534.jpeg"></p><p>下面我们手动修改/boot/config.txt文件。记得修改前备份一个，以下是参数文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For more options and information see</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://rpf.io/configtxt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Some settings may impact device functionality. See link above <span class="keyword">for</span> details</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment <span class="keyword">if</span> you get no picture on HDMI <span class="keyword">for</span> a default <span class="string">"safe"</span> mode</span></span><br><span class="line"><span class="meta">#</span><span class="bash">hdmi_safe=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment this <span class="keyword">if</span> your display has a black border of unused pixels visible</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and your display can output without overscan</span></span><br><span class="line">disable_overscan=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment the following to adjust overscan. Use positive numbers <span class="keyword">if</span> console</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> goes off screen, and negative <span class="keyword">if</span> there is too much border</span></span><br><span class="line"><span class="meta">#</span><span class="bash">overscan_left=16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">overscan_right=16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">overscan_top=16</span></span><br><span class="line"><span class="meta">#</span><span class="bash">overscan_bottom=16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a console size. By default it will be display<span class="string">'s size minus</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> overscan.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">framebuffer_width=1280</span></span><br><span class="line"><span class="meta">#</span><span class="bash">framebuffer_height=720</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment <span class="keyword">if</span> hdmi display is not detected and composite is being output</span></span><br><span class="line">hdmi_force_hotplug=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a specific HDMI mode (this will force VGA)</span></span><br><span class="line">hdmi_group=1</span><br><span class="line">hdmi_mode=4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment to force a HDMI mode rather than DVI. This can make audio work <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DMT (computer monitor) modes</span></span><br><span class="line">hdmi_drive=2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment to increase signal to HDMI, <span class="keyword">if</span> you have interference, blanking, or</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no display</span></span><br><span class="line">config_hdmi_boost=4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> uncomment <span class="keyword">for</span> composite PAL</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sdtv_mode=2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">uncomment to overclock the arm. 700 MHz is the default.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">arm_freq=800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment some or all of these to <span class="built_in">enable</span> the optional hardware interfaces</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dtparam=i2c_arm=on</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dtparam=i2s=on</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dtparam=spi=on</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment this to <span class="built_in">enable</span> the lirc-rpi module</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dtoverlay=lirc-rpi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Additional overlays and parameters are documented /boot/overlays/README</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enable audio (loads snd_bcm2835)</span></span><br><span class="line">dtparam=audio=on</span><br><span class="line">start_x=1</span><br><span class="line">gpu_mem=128</span><br><span class="line">enable_uart=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">disable_camera_led=1</span></span><br><span class="line">hdmi_ignore_edid=0xa5000080</span><br></pre></td></tr></table></figure><p>看这个<a href="https://wenku.baidu.com/view/a8a1554e71fe910ef02df893.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a8a1554e71fe910ef02df893.html</a>，学一下各个参数详解</p><p>学完之后了解一下怎么调hdmi_mode这个参数<a href="https://zhidao.baidu.com/question/519865882625562245.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/519865882625562245.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;通常情况下，树莓派会自动检测显示器的类型并修改配置。但有时，自动检测的结果可能不正确。如果你的树莓派连接到电视
      
    
    </summary>
    
      <category term="物联网" scheme="luoxiao.cf/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Google Colab</title>
    <link href="luoxiao.cf/2019/07/23/2019%E2%80%9307-23-Google%20Colab/"/>
    <id>luoxiao.cf/2019/07/23/2019–07-23-Google Colab/</id>
    <published>2019-07-23T23:34:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><h3 id="训练模型太慢怎么办"><a class="markdownIt-Anchor" href="#训练模型太慢怎么办"></a> 训练模型太慢怎么办？</h3><p>训练模型的时间，好点的用1小时2小时，遇到稍复杂的得等1天甚至2天。训练后的模型，如果不满足要求，还得再反复调整，再来一遍…这简直是个噩梦有么有。去某宝、JD上搜一搜，一台上万谁买的起。对于我们这些穷得揭不开锅的苦比党来说，Google Colab可以说是我们的福音！</p><h3 id="google-golab"><a class="markdownIt-Anchor" href="#google-golab"></a> Google Golab</h3><p>Colaboratory 是一款研究工具，用于进行机器学习和研究。它是一个 Jupyter 笔记本环境，重点是它不需要进行任何设置就可以跑代码，而且性能方面Google提供了Tesla K80 GPU，很给力了。而且它还是永久免费的，仿佛发现了新大陆ヾ(≧O≦)〃，虽然不知道性能到底怎么样，但是跟我这用了5年的烂本子比，已经不知道好到哪去了。</p><h3 id="官网"><a class="markdownIt-Anchor" href="#官网"></a> 官网</h3><p>首先这是Google的东西，想用肯定得FQ，这没啥说的，访问下面链接<a href="https://colab.research.google.com" target="_blank" rel="noopener">Google Colab</a>。Google Colab 支持Python2和Python3语言;想用R和Scala的小伙伴得忍忍了，Google方面正在研发对他们的支持，后续会开方相关功能。</p><h3 id="记事本"><a class="markdownIt-Anchor" href="#记事本"></a> 记事本</h3><p>写代码我们需要先建个“记事本”，可以通过下面两种方法建立:</p><p>1.第一次进入会弹出一个框，点框下面的 <font color="red">&quot;NEW PYTHON 3 NOTBOOK&quot;新建“记事本”<br><a href="https://i.loli.net/2019/07/23/5d3722e1577ab71988.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d3722e1577ab71988.png" alt="snapshot.png"></a></font></p><p>2.这个框关掉以后，左上角找到 File-&gt;New Python 3 Notbook<br><a href="https://i.loli.net/2019/07/23/5d372313881d457467.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d372313881d457467.png" alt="file.png"></a></p><h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3><p>点击“CODE”创建一个代码片段，你可以创建多个代码片段。</p><p><a href="https://i.loli.net/2019/07/23/5d3728ac90b5852441.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d3728ac90b5852441.png" alt="2.png"></a></p><p>下面用Python3 测试一下环境是否正常,试着打印tensorflow版本号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure><p>点击画的红色框框运行代码<br><a href="https://i.loli.net/2019/07/23/5d372439cf26465483.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/23/5d372439cf26465483.png" alt="snapshot.png"></a></p><p>参考文档汇总:</p><p><a href="https://research.google.com/colaboratory/faq.html#browsers" target="_blank" rel="noopener">官方问答</a>:<a href="https://research.google.com/colaboratory/faq.html#browsers" target="_blank" rel="noopener">https://research.google.com/colaboratory/faq.html#browsers</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;训练模型太慢怎么办&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#训练模
      
    
    </summary>
    
      <category term="机器学习" scheme="luoxiao.cf/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序的应用-优先队列</title>
    <link href="luoxiao.cf/2019/07/18/2019%E2%80%9307-18-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>luoxiao.cf/2019/07/18/2019–07-18-堆排序的应用-优先队列/</id>
    <published>2019-07-18T23:52:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>堆排序在排序复杂性的研究中有着重要的地位，因为它是我们所知的唯一能够同时最优的利用空间和时间的方法-在最坏的情况下它能保证使用～2NlgN次比较和恒定的额外空间。</p><p>在开始了解优先队列之前我们先了解一下堆的特性：</p><p>一个大根堆有这么个特性，它的爸爸总是比它的俩孩子的值大;除了这个最基本的以外，你还要知道第k个元素的左孩子是2k，右孩子是2k+1;知道这个以后，下面我们需要实现两个方法，<font color="red">高效的删除最大元素和插入元素</font>。</p><p>如果新插入一个数，那么根据前面的特性，只需要不断循环的用自身和自己的爸爸（k/2）比较大小，根据比较结果判断是否要交换位置即可;如果要删掉一个最大的数，只需要将根与最后一个数交换位置(因为根是大根堆中最大的数)，将其脱离堆结构，然后将根节点不断和它的孩子（2K、2K+1）比较大小，下沉到合适位置即可；</p><p>为了满足k,2k,2k+1的这种层级关系，后续将舍弃数组下标为0的位置，因为2*0会影响到这种层级关系的判断。</p><p>下面我们说一下下沉（sink）和上浮（swim）的实现方法</p><h3 id="上浮"><a class="markdownIt-Anchor" href="#上浮"></a> 上浮</h3><p>如果堆的有序状态因为某个节点比它的父节点更大而被打破，那么我们就需要通过交换它和它的父节点来修复堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">        exch(k/<span class="number">2</span>,k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下沉"><a class="markdownIt-Anchor" href="#下沉"></a> 下沉</h3><p>与上浮相反，如果堆有序被打破，k节点想要下沉到合适的位置，代码应该这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!less(k,j)) <span class="keyword">break</span>;</span><br><span class="line">        exch(k,j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于堆的优先队列"><a class="markdownIt-Anchor" href="#基于堆的优先队列"></a> 基于堆的优先队列</h3><p>下面我们实现一下堆的优先队列。优先队列由一个基于堆的完全二叉树表示，存储于数组pq[1…N]中,pq[0]不用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span>&#123;</span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i] &lt; pq[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(i,j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Key t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在insert()中，将N加1并把新元素添加到数组最后，然后用swim()恢复秩序。在delMax()中。从pq[1]中得到需要返回的元素，然后将pq[N]移动到pq[1],将N减一并用sink()恢复对的秩序。将pq[N+1]设为null，以便GC回收其所占空间。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;堆排序在排序复杂性的研究中有着重要的地位，因为它是我们所知的唯一能够同时最优的利用空间和时间的方法-在最坏的情
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Hive迁移老数据-动态分区</title>
    <link href="luoxiao.cf/2019/07/18/2019%E2%80%9307-17-%E8%BF%81%E7%A7%BB%E8%80%81%E6%95%B0%E6%8D%AE%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"/>
    <id>luoxiao.cf/2019/07/18/2019–07-17-迁移老数据动态分区/</id>
    <published>2019-07-18T11:18:55.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>现在有个hive表 dw_revisit_user_d ，创建的时候没有加partitioned by,现在想拓展表中的datestr当分区列。要怎么保证原来数据不丢，并且让原来的数据按datestr分区，以后的数据也按datestr分区？</p><p><a href="https://i.loli.net/2019/07/18/5d2fe458aa59551956.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/18/5d2fe458aa59551956.png" alt="9DA3BBF8-75B6-4788-8EE9-015C14D84DDD.png"></a></p><p>我们可以使用select…insert + 动态分区解决问题</p><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_1(datestr <span class="keyword">string</span>,u_id <span class="keyword">string</span>,acc_cnt <span class="built_in">bigint</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> t_1 <span class="keyword">values</span>(<span class="string">'2019-07-17'</span>,<span class="string">'1'</span>,<span class="number">22</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> t_1 <span class="keyword">values</span>(<span class="string">'2019-07-17'</span>,<span class="string">'2'</span>,<span class="number">24</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> t_1 <span class="keyword">values</span>(<span class="string">'2019-07-16'</span>,<span class="string">'3'</span>,<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_2 <span class="keyword">partition</span> (datestr)</span><br><span class="line"><span class="keyword">select</span> u_id,acc_cnt,datestr <span class="keyword">from</span> t_1 <span class="keyword">where</span> datestr = <span class="string">'2019-07-17'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_2 <span class="keyword">partition</span> (datestr)</span><br><span class="line"><span class="keyword">select</span> u_id,acc_cnt,datestr <span class="keyword">from</span> t_1 <span class="keyword">where</span> datestr = <span class="string">'2019-07-16'</span>;</span><br></pre></td></tr></table></figure><p>加上下面这句话，不带where直接自动匹配datestr</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamici.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_2 <span class="keyword">partition</span> (datestr)</span><br><span class="line"><span class="keyword">select</span> u_id,acc_cnt,datestr <span class="keyword">from</span> t_1;</span><br></pre></td></tr></table></figure><p>之后删掉t_1 修改t_2为t_1就行了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;现在有个hive表 dw_revisit_user_d ，创建的时候没有加partitioned by,现在想
      
    
    </summary>
    
      <category term="大数据" scheme="luoxiao.cf/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hive" scheme="luoxiao.cf/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>ceph集群搭建</title>
    <link href="luoxiao.cf/2019/07/17/2019-07-17-ceph/"/>
    <id>luoxiao.cf/2019/07/17/2019-07-17-ceph/</id>
    <published>2019-07-17T17:43:17.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>作者林文杰；结构图如下图所示</p><p><a href="https://i.loli.net/2019/07/17/5d2eedf4bfdf563876.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/17/5d2eedf4bfdf563876.png" alt="ceph.png"></a></p><h3 id="1-selinux-防火墙和hostname文件"><a class="markdownIt-Anchor" href="#1-selinux-防火墙和hostname文件"></a> 1、Selinux、防火墙和hostname文件</h3><p>将/etc/selinux/config文件下SELINUX=disabled</p><p>关闭防火墙或者开通6789和6800：7300的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><h3 id="2-配置用户"><a class="markdownIt-Anchor" href="#2-配置用户"></a> 2、配置用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useradd -m bdipceph</span><br><span class="line">passwd bdipceph</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置su权限</span></span><br><span class="line">echo "bdipceph ALL = (root) NOPASSWD:ALL" | tee /etc/sudoers.d/bdipceph</span><br><span class="line">chmod 0440 /etc/sudoers.d/bdipceph</span><br></pre></td></tr></table></figure><h3 id="3-将各节点写入hosts"><a class="markdownIt-Anchor" href="#3-将各节点写入hosts"></a> 3、将各节点写入hosts</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.140.130 ceph130 &gt;&gt; /etc/hosts</span><br><span class="line">echo 192.168.140.133 ceph133 &gt;&gt; /etc/hosts</span><br><span class="line">echo 192.168.140.134 ceph134 &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h3 id="4-配置免密"><a class="markdownIt-Anchor" href="#4-配置免密"></a> 4、配置免密</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">su bdipceph</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id ceph130</span><br><span class="line">ssh-copy-id ceph133</span><br><span class="line">ssh-copy-id ceph134</span><br></pre></td></tr></table></figure><h3 id="5-安装ntp服务和配置yum仓库"><a class="markdownIt-Anchor" href="#5-安装ntp服务和配置yum仓库"></a> 5、安装ntp服务和配置yum仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repo.d/CentOS-ceph.repo</span><br></pre></td></tr></table></figure><p>下面做参考</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[Ceph]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">Ceph packages for $basearch</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://mirrors.aliyun.com/ceph/rpm-jewel/el7/$basearch</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">type</span>=<span class="string">rpm-md</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://mirrors.aliyun.com/ceph/keys/release.asc</span></span><br><span class="line"><span class="attr">priority</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">[Ceph-noarch]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">Ceph noarch packages</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://mirrors.aliyun.com/ceph/rpm-jewel/el7/noarch</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">type</span>=<span class="string">rpm-md</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://mirrors.aliyun.com/ceph/keys/release.asc</span></span><br><span class="line"><span class="attr">priority</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">[ceph-source]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">Ceph source packages</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://mirrors.aliyun.com/ceph/rpm-jewel/el7/SRPMS</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">type</span>=<span class="string">rpm-md</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://mirrors.aliyun.com/ceph/keys/release.asc</span></span><br></pre></td></tr></table></figure><h3 id="6-安装存储集群"><a class="markdownIt-Anchor" href="#6-安装存储集群"></a> 6、安装存储集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install ceph-deploy</span><br><span class="line">su cephd</span><br><span class="line">mkdir ~/my-cluster</span><br><span class="line">ceph-deploy new ceph133</span><br><span class="line">osd pool default size = 2</span><br><span class="line">ceph-deploy install ceph130 ceph133 ceph134</span><br><span class="line">ceph-deploy mon create-initial</span><br><span class="line">ceph-deploy osd prepare ceph133:/var/local/osd0 ceph134:/var/local/osd1</span><br><span class="line">ceph-deploy osd activate ceph133:/var/local/osd0 ceph134:/var/local/osd1</span><br><span class="line">ceph-deploy admin ceph130 ceph133 ceph134</span><br><span class="line">chmod +r /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">ceph health</span><br></pre></td></tr></table></figure><h3 id="7-删除osd"><a class="markdownIt-Anchor" href="#7-删除osd"></a> 7、删除osd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ceph osd out 1</span><br><span class="line">systemctl stop ceph-osd@1</span><br><span class="line">ceph osd crush remove osd.1</span><br><span class="line">ceph auth del osd.1</span><br><span class="line">ceph osd rm osd.1</span><br><span class="line"><span class="meta">#</span><span class="bash">删除旧文件夹</span></span><br><span class="line">rm -rf /var/local/osd1</span><br><span class="line"><span class="meta">#</span><span class="bash">调整权重</span></span><br><span class="line">ceph osd crush reweight osd.1 0</span><br></pre></td></tr></table></figure><h3 id="8-配置文件修改发送"><a class="markdownIt-Anchor" href="#8-配置文件修改发送"></a> 8、配置文件修改发送</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf config push bdipceph104 bdipceph106 bdipceph108</span><br></pre></td></tr></table></figure><h3 id="9-配置文件内容"><a class="markdownIt-Anchor" href="#9-配置文件内容"></a> 9、配置文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置日志文件大小</span></span><br><span class="line">osd journal size = 1024</span><br><span class="line"><span class="meta">#</span><span class="bash">设置节点数量</span></span><br><span class="line">osd pool default size = 3</span><br><span class="line"><span class="meta">#</span><span class="bash">设置副本数量</span></span><br><span class="line">osd pool default min size = 2</span><br><span class="line"><span class="meta">#</span><span class="bash">设置ext4能够使用</span></span><br><span class="line">osd max object name len = 256</span><br><span class="line">osd max object namespace len = 64</span><br></pre></td></tr></table></figure><h3 id="10-创建块设备"><a class="markdownIt-Anchor" href="#10-创建块设备"></a> 10、创建块设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建映像foo大小4G</span></span><br><span class="line">rbd create --size 4096 foo</span><br><span class="line"><span class="meta">#</span><span class="bash">查询映像</span></span><br><span class="line">rbd ls</span><br><span class="line"><span class="meta">#</span><span class="bash">查询单个映像信息</span></span><br><span class="line">rbd info foo</span><br><span class="line"><span class="meta">#</span><span class="bash">扩大映像大小</span></span><br><span class="line">rbd resize --size 8192 foo</span><br><span class="line">resize2fs /dev/rbd0</span><br><span class="line"><span class="meta">#</span><span class="bash">减小映像大小(会损坏数据)</span></span><br><span class="line">rbd resize --size 4096 foo --allow-shrink</span><br><span class="line"><span class="meta">#</span><span class="bash">删除映像</span></span><br><span class="line">rbd rm foo</span><br><span class="line"><span class="meta">#</span><span class="bash">linux环境需要执行下面这条命令</span></span><br><span class="line">rbd feature disable foo exclusive-lock object-map fast-diff deep-flatten</span><br><span class="line"><span class="meta">#</span><span class="bash">映射块设备</span></span><br><span class="line">rbd map foo --name client.admin </span><br><span class="line"><span class="meta">#</span><span class="bash">查看已映射块设备</span></span><br><span class="line">rbd showmapped</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取消块设备映射</span></span><br><span class="line">rbd unmap /dev/rbd0</span><br><span class="line">mkfs.ext4 /dev/rbd0</span><br></pre></td></tr></table></figure><h3 id="11-创建块设备快照"><a class="markdownIt-Anchor" href="#11-创建块设备快照"></a> 11、创建块设备快照</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建快照</span></span><br><span class="line">rbd snap create rbd/foo@snapfoo</span><br><span class="line"><span class="meta">#</span><span class="bash">罗列快照</span></span><br><span class="line">rbd snap ls rbd/foo</span><br><span class="line"><span class="meta">#</span><span class="bash">回滚快照</span></span><br><span class="line">rbd snap rollback rbd/foo@snapfoo</span><br><span class="line"><span class="meta">#</span><span class="bash">删除快照</span></span><br><span class="line">rbd snap rm rbd/foo@snapfoo</span><br><span class="line"><span class="meta">#</span><span class="bash">清除快照</span></span><br><span class="line">rbd snap purge rbd/foo</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;作者林文杰；结构图如下图所示&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.loli.net/2019/0
      
    
    </summary>
    
      <category term="大数据" scheme="luoxiao.cf/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="ceph" scheme="luoxiao.cf/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>Export requires a --table or a --call argument</title>
    <link href="luoxiao.cf/2019/07/16/2019%E2%80%9307-16-Export-requires-a--table-or-a--call-argument/"/>
    <id>luoxiao.cf/2019/07/16/2019–07-16-Export-requires-a--table-or-a--call-argument/</id>
    <published>2019-07-16T11:03:59.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>参考官方文档<a href="http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html#_failed_exports" target="_blank" rel="noopener">10. sqoop-export</a>使用Sqoop导入数据到RDSMS数据库，结果报错；错误也是让人摸不着头脑，命令中是有这些参数的。</p><p><a href="https://i.loli.net/2019/07/16/5d2d42330c66764831.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/16/5d2d42330c66764831.png" alt="1.png"></a></p><h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3><p>做下面修改，在值的左右加上<font color="red">双引号</font>即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--connect "jdbc:sqlserver://ip:port;database=database" \</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;参考官方文档&lt;a href=&quot;http://sqoop.apache.org/docs/1.4.6/Sqoop
      
    
    </summary>
    
      <category term="其他" scheme="luoxiao.cf/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="问题总结" scheme="luoxiao.cf/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>分布式幂等性设计</title>
    <link href="luoxiao.cf/2019/07/15/2019%E2%80%9307-15-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>luoxiao.cf/2019/07/15/2019–07-15-分布式幂等性设计/</id>
    <published>2019-07-15T20:57:00.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><h3 id="幂等性"><a class="markdownIt-Anchor" href="#幂等性"></a> 幂等性</h3><p>幂等性指的是，请求一次或者是多次资源应该具有相同的副作用。</p><h3 id="重要性"><a class="markdownIt-Anchor" href="#重要性"></a> 重要性</h3><p>在一些业务场景下，幂等性显得很重要；比如金融系统、电商系统，这些都是很敏感的系统，作为软件开发者，我们有必要了解一下它。</p><ul><li>订单创建接口，第一次调用超时了，如果再调用一次会不会再创建一个订单？</li><li>购买商品时，减库存接口超时了，再调一次会不会扣减2个库存？</li><li>当一笔订单开始支付，支付请求发出后，服务端发生了扣钱操作，接口响应超时了，调用方再重试一次，会不会多扣一笔钱？</li></ul><p>下面我们介绍一下怎么解决上面所述的问题。</p><h3 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h3><p>通常我们有两个方法来保证幂等性。也就是不管调用接口多少次，都要产生相同的副作用：</p><ul><li>下游做一个查询接口，上游系统发现请求超时后，调用查询接口。发现成功了，逻辑里面什么都不用做；如果发现失败了，走失败流程进行后续处理保证最终结果正确。</li><li>把这个查询操作交给下游系统，上游系统只负责重试，下游系统要在代码上保证一次或多次请求结果是一样的.</li></ul><p>第一种没什么好说的，很好实现；第二种则需要利用一个全局ID来辅助完成。由于我们的系统是一个分布式的，要做到全局唯一貌有点小难度，分布式中，子系统很多。该由谁来维护这个全局ID？这里介绍一下Twitter 的开源项目Snowflake。它是一个分布式ID的生成算法，可以帮我们完成这个工作，你可以通过阅读下面这个文章来交接它https://www.cnblogs.com/haoxinyue/p/5208136.html</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;幂等性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#幂等性&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="分布式" scheme="luoxiao.cf/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>排序空间复杂度与稳定性</title>
    <link href="luoxiao.cf/2019/07/08/2019%E2%80%9307-08-%E6%8E%92%E5%BA%8F%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>luoxiao.cf/2019/07/08/2019–07-08-排序空间复杂度与稳定性/</id>
    <published>2019-07-08T19:34:38.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>8种经典排序算法已经整理完成，下面说一下他们的空间复杂度</p><h3 id="o1"><a class="markdownIt-Anchor" href="#o1"></a> O（1）</h3><p>插入排序、冒泡排序、选择排序、希尔排序、堆排序</p><h3 id="on~ologn"><a class="markdownIt-Anchor" href="#on~ologn"></a> O（n）～O（logn）</h3><p>快速排序</p><h3 id="on"><a class="markdownIt-Anchor" href="#on"></a> O（N）</h3><p>归并排序</p><blockquote><p>这里有一些网上和书上说可以将归并排序的空间复杂度优化到O（1），这边通过手摇算法确实可以使得空间复杂度达到O（1），但是时间复杂度会上升。</p></blockquote><h3 id="om"><a class="markdownIt-Anchor" href="#om"></a> O（M）</h3><p>计数排序、基数排序</p><blockquote><p>这个M代表的是桶的数量</p></blockquote><h3 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h3><p>所谓不稳定性，指的是相同元素经过排序后，改变了原数组中数的位置，即为不稳定的排序算法。</p><p>8种排序算法中，有选择排序、快速排序、希尔排序和堆排序他们是不稳定的排序算法</p><p>那么我们下面说一下，对于序列（5,5,5,1），为什么他们会是不稳定的排序算法</p><h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h4><p>选择排序，会将1与第一个5进行交换位置，导致相同元素排序后位置改变。</p><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><p>对于快排而言，开始任意选择一个数，假如选到了第二个5,那么小于等于它的都将会被放到第二个5的左边，导致相同元素排序后位置改变。</p><h4 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h4><p>假如希尔排序的步长选为2,在1和第二个5比较以后，会和它交换位置，导致相同元素排序后位置改变。</p><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><p>将上面元素映射为大根堆，堆顶元素会和最后一个元素交换位置，导致相同元素排序后位置改变。</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><ol><li><p>在解决工程问题时，通常会使用多个排序算法相结合的套路，来解决问题。面对问题时要活学活用，比如使用计数排序解决按身高排序的问题很高效，但是放在解决按工资排序的问题上就不是那么好了。</p></li><li><p>一般，对于数量不大的情况下，通常选取时间复杂度为O（n^2）的插入排序算法</p></li><li><p>对于数量很大的情况下，通常选取快速排序，或者是其他的时间复杂度为O（nlogn）的排序算法</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;8种经典排序算法已经整理完成，下面说一下他们的空间复杂度&lt;/p&gt;&lt;h3 id=&quot;o1&quot;&gt;&lt;a class=&quot;m
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>计数和基数排序</title>
    <link href="luoxiao.cf/2019/07/08/2019%E2%80%9307-08-%E8%AE%A1%E6%95%B0%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>luoxiao.cf/2019/07/08/2019–07-08-计数和基数排序/</id>
    <published>2019-07-08T19:34:38.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>O（N）的排序算法也叫不比较的排序算法，它的思想源于桶排序，其中比较经典的两个例子<font color="red">计数排序和基数排序</font>，它们的时间复杂度趋向于O（n）</p><p>你可能会纳闷，不比较也能排序？下面我们介绍一下这两种经典排序算法</p><h3 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h3><p>假如要给公司员工按身高排序。</p><ol><li><p>我们知道员工身高大部分在160，180 之间，建立100～300一共200个桶。</p></li><li><p>遍历所有员工，按身高把员工放到匹配的桶中</p></li><li><p>分别倒出100～300号桶中的员工，这就是一个按身高排好序的序列。</p></li></ol><h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h3><p>给下面序列 （124，220，044，120，334，666，001，099）排序，其中都为10进制数；</p><ol><li><p>建立 0～9 共10个桶</p></li><li><p>根据上面数的个位，分别放到对应的桶中，比如124，个位是4，就放到4对应的桶中；</p></li><li><p>依次倒出所有数，再根据数的十位，分别放到对应的桶中；</p></li><li><p>依次倒出所有数，再根据数的百位，分别放到对应的桶中；</p></li><li><p>依次倒出所有的数，该序列就是从小到大的有序序列；</p></li></ol><p>下面这个网站中可以给你一些好的桶排序的思想，如果有时间，不妨看一下图解<br><a href="https://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="noopener">Bucket Sort</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/CountingSort.html" target="_blank" rel="noopener">Counting Sort</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="noopener">Radix Sort</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;O（N）的排序算法也叫不比较的排序算法，它的思想源于桶排序，其中比较经典的两个例子&lt;font color=&quot;r
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>希尔、归并、堆、快速排序</title>
    <link href="luoxiao.cf/2019/07/08/2019%E2%80%9307-03-%E5%B8%8C%E5%B0%94%E3%80%81%E5%BD%92%E5%B9%B6%E3%80%81%E5%A0%86%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>luoxiao.cf/2019/07/08/2019–07-03-希尔、归并、堆、快速排序/</id>
    <published>2019-07-08T19:34:38.000Z</published>
    <updated>2019-11-13T04:56:08.680Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>下面我们介绍一下时间复杂度为O（nlogn）的时间复杂度:<font color="red">希尔排序、归并排序、堆排序、快速排序</font></p><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><ol><li><p>将0～（n-1）的无序列表，映射为大根堆，根据大根堆的特性，堆顶为最大值;</p></li><li><p>将堆顶与堆的最后一个元素交换位置，并将其脱离堆结构，放在数组n-1位置上;</p></li><li><p>重新调整大根堆，重复步骤2，得到第n-2的数</p></li><li><p>直到堆元素个数为1，即整个堆排序完成。</p></li></ol><p>图解流程访问下面链接中的 <a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><p>希尔排序是插入排序的进化版，插入排序的每次迁移步长为1,而希尔排序则通过动态调整步长，进而提高排序效率。假如选定步长为3下面说一下排序过程</p><ol><li><p>在0～（N-1）的无序序列中，数组中位置0、1、2三个数将被直接跳过。取3位置的数（a）和0位置上的数（b）比较。如果b&gt;a,则结束比较;如果b&lt;a,则交换b和a的位置，继续使用b和-3位置上的数比较，发现-3数组越界，结束比较;</p></li><li><p>取位置4上的数和位置1上的数比较，重复上面过程;</p></li><li><p>一直到最后一个位置n与n-3比较后结束步长为3的排序过程;</p></li><li><p>让步长减1继续完成上面1、2、3的步骤，知道步长=0,结束整个希尔排序过程;</p></li></ol><p>图解流程访问下面链接中的Shell Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希尔排序其实是插入排序的一种优化</span></span><br><span class="line">    <span class="keyword">int</span> len = a.length;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义w的规则</span></span><br><span class="line">    <span class="keyword">while</span>(w &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        w = <span class="number">3</span>*w + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始进行排序</span></span><br><span class="line">    <span class="keyword">while</span>(w &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = w ; i &lt; len ; i ++)&#123;</span><br><span class="line">            <span class="comment">// 将a[i]插入到a[i-w]、a[i-2*w]、a[i-3*w]....</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= w &amp;&amp; less(a[j],a[j-w]) ; j -=w )&#123;</span><br><span class="line">                exch(a,j,j-w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        w = w / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><ol><li><p>在0～（n-1）的无序列表中，将大小为1的有序区间，合并为大小为2的有序区间;</p></li><li><p>将大小为2的有序区间合并为大小为4的有序区间;</p></li><li><p>直到有序区间大小容纳所有的数，归并排序完成;</p></li></ol><p>图解流程访问下面链接中的Merge Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自上而下的归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a[lo...mid] 和 a[mid+1....hi]</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">    sort(a,lo,mid);</span><br><span class="line">    sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">    merge(a,lo,mid,hi);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并 a[lo...mid] 和 a[mid+1....hi]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化两个指针</span></span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将a复制到辅助数组aux</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始拿两个指针对应的数进行比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="comment">// j对应的数 比i小，将比较小的放在第k位置</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt; hi)&#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; mid)&#123;<span class="comment">// 如果左边用完了，直接将右序列中的数放在k位置</span></span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i]))&#123; <span class="comment">// 如果右边用完了，直接将左序列中的数放在k位置</span></span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p>利用分治的思想，要对大小为N的无序序列排序，将其分为a[lo]-a[j-1],a[j],a[j+1]-a[hi]三部分，保证a[lo]-a[j-1]中的数永远小于等于a[j];a[j+1]-a[hi]中的数永远大于a[j];</p><p>在分别递归的对a[lo]-a[j-1]和a[j+1]-a[hi]重复上面的步骤。</p><p>下面我们说一下什么叫划分过程，划分过程就是怎么将小于等于a[j]的数放到a[j]的左边，大于a[j]的数放在了a[j]的右边：</p><ol><li><p>选择一个数a[lo]，初始化左指针 i = lo ，右指针 j = hi；</p></li><li><p>i指针往右移，找到大于等于a[lo]的数(a);j指针往左移，找到小于a[lo]的数b。交换a和b的位置,然后i继续往右移，j继续往左移，直到两者交汇。</p></li><li><p>将a[lo]与a[j]交换位置</p></li></ol><p>图解流程访问下面链接中的Quick Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo ,<span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到j,分别对a[lo..j-1]和a[j+1...hi]进行递归快速的排序</span></span><br><span class="line">    <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">    <span class="comment">// sort左序列\ sort右序列</span></span><br><span class="line">    sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">    sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对a[lo...hi] 进行划分排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针</span></span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 从左边往右边一直找到第一个比v大的数</span></span><br><span class="line">        <span class="keyword">while</span>(less(a[++i],v))<span class="keyword">if</span>(i == hi)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 从右边往左边一直找到第一个比v小的数</span></span><br><span class="line">        <span class="keyword">while</span>(less(v,a[--j]) )<span class="keyword">if</span>(j == lo)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后将j和lo位置上的数互换</span></span><br><span class="line">    exch(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;下面我们介绍一下时间复杂度为O（nlogn）的时间复杂度:&lt;font color=&quot;red&quot;&gt;希尔排序、归并排
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>冒泡、插入、选择排序</title>
    <link href="luoxiao.cf/2019/07/03/2019-07-03-%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>luoxiao.cf/2019/07/03/2019-07-03-冒泡、插入、选择排序/</id>
    <published>2019-07-03T20:54:38.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>下面我们来理一下时间复杂度为O（n^2）的排序算法：<font color="red">冒泡排序、插入排序和选择排序</font></p><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><ol><li><p>在0～（N-1）的大小区间中，数组位置0和数组位置1上的进行比较，如果0位置上的大于1位置上的，交换他们的位置，否则不动；紧接着位置1上的和位置2上的进行比较，如果1位置上的大于2位置上的，交换他们的位置，如此反复第一轮下来，数组中最大的那个数会被放到数组的最后面。</p></li><li><p>将0～（N-1）的区间缩小为0～（N-2），反复上述过程。第二轮下来后，最大的会被放到倒数第二个位置。</p></li><li><p>以此类推完成后面各轮过程，直到数组区间大小为1，即整个过程结束。</p></li></ol><p>图解流程访问下面链接中的Bubble Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">less</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exch</span><span class="params">(a *<span class="keyword">int</span>, b *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">temp := *a</span><br><span class="line">*a = *b</span><br><span class="line">*b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bsort</span><span class="params">(a *[10]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">count := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="comment">//fmt.Println(count)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; count; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> less(a[j], a[i]) &#123;</span><br><span class="line">exch(&amp;(*a)[j],&amp;(*a)[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">14</span>,<span class="number">2232</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">62</span>,<span class="number">351</span>,<span class="number">422</span>,<span class="number">123</span>,<span class="number">34</span>&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">//fmt.Println(count)</span></span><br><span class="line">bsort(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><ol><li><p>数组0位置（a）和数组1位置（b）上的数进行比较，如果后者b比前者a小，将b与a交换位置，紧接着b再和数组-1上的位置进行比较，发现数组越越界，结束第一轮的过程。</p></li><li><p>将待处理区间的大小缩小为1～（N-1），数组1位置上的数（a）与数组2位置上的数（b<br>）进行比较，同样的，如果后者b比前者a小，就将两个数进行交换，继续拿数组1位置上的数与数0位置上的数进行比较直到不满足后者小于前者，或者数组越界为止。结束第二轮的过程。</p></li><li><p>反复上面的过程直到待比较区间大小为1停止整个插入排序。</p></li></ol><p>图解流程访问下面链接中的Insertion Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        <span class="comment">// 将a[i] 插入到 a[i - 1] , a[i - 2], a[ i - 3]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= <span class="number">1</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]) ; j -= <span class="number">1</span>)&#123;</span><br><span class="line">            exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><ol><li><p>在0～（N-1）的比较区间中，从头到尾依次比较找出最小的数，放在位置0上，将区间长度变为1～（N-1）</p></li><li><p>在1～（N-1）的比较区间中，从头到尾依次比较找出最小的数，放在位置1上，将区间长度变为2～（N-1）</p></li><li><p>反复上述过程知道比较区间大小为0，结束整个排序过程。</p></li></ol><p>图解流程访问下面链接中的Selection Sort <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; len  ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( less(a[j],a[min]) ) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            exch (a,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;下面我们来理一下时间复杂度为O（n^2）的排序算法：&lt;font color=&quot;red&quot;&gt;冒泡排序、插入排序和选
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>最好、最坏、平均 、均摊时间复杂度</title>
    <link href="luoxiao.cf/2019/07/03/2019-07-03-%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%20%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>luoxiao.cf/2019/07/03/2019-07-03-最好、最坏、平均 、均摊时间复杂度/</id>
    <published>2019-07-03T20:42:05.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>较为复杂的分析方法大致可分为四类、分别为：<font color="red">最好时间复杂度、最坏时间复杂度、平均时间复杂度和均摊时间复杂度</font>。</p><p>这里有一段代码，针对它下面分别来说一下怎么算着四种时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i的取值范围是 0～n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      new_array[j] = array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    array = new_array;</span><br><span class="line">    len = <span class="number">2</span> * len;</span><br><span class="line">  &#125;</span><br><span class="line">  array[i] = element;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最好-最坏时间复杂度"><a class="markdownIt-Anchor" href="#最好-最坏时间复杂度"></a> 最好、最坏时间复杂度</h3><p>最好时间复杂度，言明直意，就是在最好情况下求得的时间复杂度，对于上面代码，针对长度为N的数组添加一个元素的最好时间复杂度为O（1）</p><p>在最好情况下，数组空间很充足，可以直接将数组添加到第i位置</p><p>在最坏情况下，数组空间不够，所以要重新申请一个2倍大小的数组空间，把原来array数组中的数据依次copy到new_array，因此最坏的时间复杂度应该是O（N）</p><h3 id="平均时间复杂度"><a class="markdownIt-Anchor" href="#平均时间复杂度"></a> 平均时间复杂度</h3><p>最好、坏的时间复杂度局限性很大，有时不能准确说明问题，针对这种情况，我们用代码执行各种情况的加权平均值来说明问题。</p><p>假设数组的大小为N，i的取值范围为0～N，在0～n-1时间复杂度为O（1），在i等于N的时候时间复杂度为O（N），i的取值有1/（n-1）种可能性，所以有：</p><p><a href="https://i.loli.net/2019/07/03/5d1c9ddc07f6c71312.jpeg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/03/5d1c9ddc07f6c71312.jpeg" alt="06D6CABC-665D-422E-B3A6-CB2C6F1076C9.jpeg"></a></p><p>最终平均时间复杂度是O（1）</p><h3 id="均摊时间复杂度"><a class="markdownIt-Anchor" href="#均摊时间复杂度"></a> 均摊时间复杂度</h3><p>网上有好多说平均时间复杂度就是均摊时间复杂度，它们并没有什么区别，不管他们俩是否一样，这边有两个tip来帮助我们算出均摊时间复杂度</p><ol><li>在N种情况中，如果第被低阶复杂度占去了半壁江山，那么通过均摊更高阶的复杂度到低阶上，最终结果为低阶复杂度。</li><li>假如你发现低阶复杂度和高阶复杂度出现规律性的交替，那么通常最终结果为低阶复杂度。</li></ol><p>根据上面的tips。很快就得出它的均摊时间复杂度为O（1）</p><h3 id="为什么要引入这4种复杂度"><a class="markdownIt-Anchor" href="#为什么要引入这4种复杂度"></a> 为什么要引入这4种复杂度？</h3><p>一般我们用不到到这些分析方法，针对某些场景，如果普通的分析方法不能论证我们的论点，那么使用它们往往可以使论点更具有说服力。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;较为复杂的分析方法大致可分为四类、分别为：&lt;font color=&quot;red&quot;&gt;最好时间复杂度、最坏时间复杂度、
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>时间空间复杂度</title>
    <link href="luoxiao.cf/2019/07/01/2019-07-01-%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>luoxiao.cf/2019/07/01/2019-07-01-时间空间复杂度/</id>
    <published>2019-07-01T11:15:05.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:55 GMT+0000 (Coordinated Universal Time) --><p>算法与数据结构相辅相成，谁也离不开谁，学算法和数据结构可以说让我很痛苦，当然对于聪明的你来说，这可能不是什么难事,哈哈哈。这下面的图是算法的整个知识体系图，通过让我们对整个算法体系有个初步了解。</p><p><a href="https://i.loli.net/2019/07/01/5d197b9bcad7383009.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d197b9bcad7383009.jpg" alt="sf_1.jpg"></a></p><p>我总结了20个最常用的、最基础数据结构与算法,他们分别是10个数据结构：<font color="red">数组、</font><font color="red">链表、</font><font color="red">栈、</font><font color="red">队列、</font><font color="red">散列表、</font><font color="red">二叉树、</font><font color="red">堆、</font><font color="red">跳表、</font><font color="red">图、</font><font color="red">Trie树；10个算法：<font color="red">递归、</font><font color="red">排序、</font><font color="red">二分查找、</font><font color="red">搜索、</font><font color="red">哈希算法、</font><font color="red">贪心算法、</font><font color="red">分治算法、</font><font color="red">回溯算法、</font><font color="red">动态规划、</font><font color="red">字符串匹配</font>算法。</font></p><p>如果想学好算法，就得掌握怎么分析代码的性能。业界中常用时间复杂度和空间复杂度来坑量，类似O(1)、O(n)、O(n^2)等。如果说不会求时间和空间复杂度，那只能说你和算法无缘了！下面我们来理理到底应该怎么算，另外算这些东西不需要什么很高深的数学，只需要高中数学知识就足够了。下面会牵扯到一些对数运算，如果你忘了，建议你回去复习一下。</p><h3 id="大o复杂度表示法"><a class="markdownIt-Anchor" href="#大o复杂度表示法"></a> 大O复杂度表示法</h3><p>这里有段非常简单的代码，求1,2,3…n的累加和。现在，我就带你一块来估算一下这段代码的执行时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设每行代码执行的时间都一样，为unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p><p>第2、3行代码分别需要1个unit_time的执行时间，第4、5行都运行了n遍，所以需要2n * unit_time的执行时间，所以这段代码总的执行时间就是(2n+2) * unit_time。可以看出来，<strong>所有代码的执行时间T(n)与每行代码的执行次数成正比</strong></p><p>按照这个分析思路，我们再来看这段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">sum = sum +  i * j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依旧假设每个语句的执行时间是unit_time。那这段代码的总执行时间T(n)是多少呢？</p><p>第2、3、4行代码，每行都需要1个unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n * unit_time的执行时间，第7、8行代码循环执行了n^2 遍，所以需要 2n^2 * unit_time的执行时间。所以，整段代码总的执行时间T(n) = (2n ^ 2 + 2n+3)*unit_time</p><p>尽管我们不知道unit_time的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<font color="red">所有代码的执行时间T(n)与每行代码的执行次数n成正比</font>。</p><p>我们可以把这个规律总结成一个公式。注意，大O就要登场了！</p><p><a href="https://i.loli.net/2019/07/01/5d1990ab0c2ec77731.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d1990ab0c2ec77731.png" alt="sf_2.png"></a></p><p>我来具体解释一下这个公式。其中，T(n)我们已经讲过了，它表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。</p><p>所以，第一个例子中的T(n) = O(2n+2)，第二个例子中的T(n) = O(2n^2+2n+3)。这就是<strong>大O时间复杂度表示法</strong>。大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p><p>当n很大时，你可以把它想象成10000、100000。而公式中的<font color="red">低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略</font>。我们只需要记录一个最大量级就可以了，如果用大O表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n^2)。</p><h3 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h3><p>前面介绍了大O时间复杂度的由来和表示方法。现在我们来看下，如何分析一段代码的时间复杂度？我这儿有三个比较实用的方法可以分享给你。</p><h4 id="1只关注循环执行次数最多的一段代码"><a class="markdownIt-Anchor" href="#1只关注循环执行次数最多的一段代码"></a> 1.只关注循环执行次数最多的一段代码</h4><p>我刚才说了，大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p><p>为了便于你理解，我还拿前面的例子来说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p><h4 id="2加法法则总复杂度等于量级最大的那段代码的复杂度"><a class="markdownIt-Anchor" href="#2加法法则总复杂度等于量级最大的那段代码的复杂度"></a> 2.加法法则：总复杂度等于量级最大的那段代码的复杂度</h4><p>我这里还有一段代码。你可以先试着分析一下，然后再往下看跟我的分析思路是否一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">sum_1 = sum_1 + p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">sum_2 = sum_2 + q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">j = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">sum_3 = sum_3 +  i * j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p><p>第一段的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。</p><p>这里我要再强调一下，即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n)和O(n^2)，你应该能容易就分析出来，我就不啰嗦了。</p><p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n^2)。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p><p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p><h4 id="3乘法法则嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a class="markdownIt-Anchor" href="#3乘法法则嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a> 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4><p>我刚讲了一个复杂度分析中的加法法则，这儿还有一个<strong>乘法法则</strong>。类比一下，你应该能“猜到”公式是什么样子的吧？</p><p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n)).</p><p>也就是说，假设T1(n) = O(n)，T2(n) = O(n^2)，则T1(n) * T2(n) = O(n^3)。落实到具体的代码上，我们可以把乘法法则看成是<strong>嵌套循环</strong>，我举个例子给你解释一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">ret = ret + f(i);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以，整个cal()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)。</p><p>我刚刚讲了三种复杂度的分析技巧。不过，你并不用刻意去记忆。实际上，复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”。</p><h3 id="几种常见时间复杂度实例分析"><a class="markdownIt-Anchor" href="#几种常见时间复杂度实例分析"></a> 几种常见时间复杂度实例分析</h3><p>虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。</p><p><a href="https://i.loli.net/2019/07/01/5d1992d63e0b039265.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d1992d63e0b039265.jpg" alt="sf_3.jpg"></a></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2^n)和O(n!)。</p><p>当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于NP时间复杂度我就不展开讲了。我们主要来看几种常见的<strong>多项式时间复杂度</strong>。</p><h4 id="1-o1"><a class="markdownIt-Anchor" href="#1-o1"></a> 1. O(1)</h4><p>首先你必须明确一个概念，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是O(1），而不是O(3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><p>我稍微总结一下，只要代码的执行时间不随n的增大而增长，这样代码的时间复杂度我们都记作O(1)。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p><h4 id="2-ologn-onlogn"><a class="markdownIt-Anchor" href="#2-ologn-onlogn"></a> 2. O(logn)、O(nlogn)</h4><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2。当大于n时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量i的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><p><a href="https://i.loli.net/2019/07/01/5d19935fd6bd034165.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d19935fd6bd034165.jpg" alt="sf_4.jpg"></a></p><p>所以，我们只要知道x值是多少，就知道这行代码执行的次数了。通过2 ^ x=n求解x这个问题我们想高中应该就学过了，我就不多说了。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>log</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">x=\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mord mathit">n</span></span></span></span> <font color="red">(以2为底)</font>所以，这段代码的时间复杂度就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><font color="red">(以2为底)</font></p><p>现在，把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">    i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> <font color="red">(以3为底)</font>。</p><p>实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><font color="red">(以2为底)</font>。为什么呢，我知道有些人忘了，下面我帮你论证了一下，用对数的换底公式就可以了！</p><p><a href="https://i.loli.net/2019/07/01/5d19a5c4ada8311497.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d19a5c4ada8311497.jpg" alt="sf_6.jpg"></a></p><p>基于我们前面的一个理论：<strong>在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n))</strong>。所以，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> <font color="red">(以2为底)</font> 就等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> <font color="red">(以3为底)</font>。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p><p>如果你理解了我前面讲的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，那<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，我们循环执行n遍，时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>了。而且，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="3omn-omn"><a class="markdownIt-Anchor" href="#3omn-omn"></a> 3.O(m+n)、O(m*n)</h4><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度<strong>由两个数据的规模</strong>来决定。老规矩，先看代码！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">sum_1 = sum_1 + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">sum_2 = sum_2 + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p><h3 id="空间复杂度分析"><a class="markdownIt-Anchor" href="#空间复杂度分析"></a> 空间复杂度分析</h3><p>前面，咱们花了很长时间讲大O表示法和时间复杂度分析，理解了前面讲的内容，空间复杂度分析方法学起来就非常简单了</p><p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>我还是拿具体的例子来给你说明。（这段代码有点“傻”，一般没人会这么写，我这么写只是为了方便给你解释。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">a[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">print out a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟时间复杂度分析一样，我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。</p><p>我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>基础复杂度分析的知识到此就讲完了，我们来总结一下。</p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。</p><p><a href="https://i.loli.net/2019/07/01/5d199477cc53579735.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/01/5d199477cc53579735.jpg" alt="sf_5.jpg"></a></p><p>复杂度分析并不难，关键在于多练。 之后讲后面的内容时，我还会带你详细地分析每一种数据结构和算法的时间、空间复杂度。只要跟着我的思路学习、练习，你很快就能和我一样，每次看到代码的时候，简单的一眼就能看出其复杂度，难的稍微分析一下就能得出答案。</p><p>转自《数据结构与算法之美》–王争</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:55 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;算法与数据结构相辅相成，谁也离不开谁，学算法和数据结构可以说让我很痛苦，当然对于聪明的你来说，这可能不是什么难
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="luoxiao.cf/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>轻办公神器</title>
    <link href="luoxiao.cf/2019/06/28/2019-06-28-%E8%BD%BB%E5%8A%9E%E5%85%AC%E7%A5%9E%E5%99%A8/"/>
    <id>luoxiao.cf/2019/06/28/2019-06-28-轻办公神器/</id>
    <published>2019-06-28T14:18:20.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>推荐APP Termiuus、Working copy、Textastic</p><p><a href="https://i.loli.net/2019/06/28/5d161118d453868515.jpeg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/28/5d161118d453868515.jpeg" alt="D8631229-E250-4C80-8342-EFC21F09C042.jpeg"></a></p><p><a href="https://i.loli.net/2019/06/28/5d16123cf046f65815.jpeg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/28/5d16123cf046f65815.jpeg" alt="D615F0B3-A693-4B22-BDCD-373B0311B150.jpeg"></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;推荐APP Termiuus、Working copy、Textastic&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="其他" scheme="luoxiao.cf/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Hbase读写操作</title>
    <link href="luoxiao.cf/2019/06/28/2019-06-28-Hbase%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/"/>
    <id>luoxiao.cf/2019/06/28/2019-06-28-Hbase读写操作/</id>
    <published>2019-06-28T14:18:20.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>HDFS、MR解决了分布式存储和分布式计算问题，但是由于HDFS的随机读写能力太差，所以不能直接作为数据库。Hbase是为了应对这点而诞生的，它是一个高性能、高可靠、可伸缩、面向列的分布式存储数据库，结合Zookeeper可以解决HDFS随机读写能力差的问题。那么它到底是怎么解决随机读写能力太差的问题呢？试想一下如果想要1S 往某个文件中插入100条记录，如果没有HBase，用Java代码写会是一种什么样的操作？可能我们需要100次的IO才能搞定。但上面假设一层缓冲层用来缓存一下， 当缓冲池满了以后再往文件中写，会不会好很多？</p><p>以Mysql为例，我们都知道Mysql的表，库等数据最终都会落在磁盘上，Mysql只不过是架设在OS文件系统上的一款解析软件而已，帮准你用流完成文件的读写。HDFS相当于OS文件系统，HBase和Mysql一样相当于一个解析器。</p><h3 id="hbase架构图"><a class="markdownIt-Anchor" href="#hbase架构图"></a> Hbase架构图</h3><p>被网上的图片坑的很，HLog组件应该归属于HRegionServer管，但是图中却把HLog画到了HRegion中，也有可能是版本问题？</p><p><a href="https://i.loli.net/2019/06/28/5d16122ace33729145.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/28/5d16122ace33729145.png" alt="832D942C-0F84-4A35-B616-DE77FC9CA2CC.png"></a></p><p>下面的图摘自《HBase权威指南》</p><p><a href="https://i.loli.net/2019/06/28/5d1612c8393c545109.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/28/5d1612c8393c545109.png" alt="DB1A798C-2F6D-43FB-B609-FBF8824B8FFD.png"></a></p><h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3><p>当Client向HRegionServer发起put请求时，其将会交给对应的HRegion来处理</p><p>首先HRegion会看是否需要写入HLog（WAL用于做数据恢复和数据回滚）</p><p>当数据持久化到HLog后，数据会被直接写到MemStore中，并检查MemStore是否满了，如果满了，数据会被刷到HDFS上以HFile文件类型存储，这个操作由另一个HRegionServer的线程处理，同时会保存最后写入序号，系统就知道哪些数据被持久化了。</p><p>摘自《HBase权威指南》–8.2.2写路径</p><h3 id="读操作"><a class="markdownIt-Anchor" href="#读操作"></a> 读操作</h3><p>很纳闷为啥HBase权威指南里面没找到读数据的章节，下面摘自网络流转的说法，具体需要看一下源码验证</p><p>首先Client向HRegionServer发送Get请求，HRegion将其请求提交给对应的HRegion</p><p>HRegion会先从MemStore中找，如果找到则返回，如果没有或者数据不全，则去StoreFile中寻找</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;HDFS、MR解决了分布式存储和分布式计算问题，但是由于HDFS的随机读写能力太差，所以不能直接作为数据库。H
      
    
    </summary>
    
      <category term="大数据" scheme="luoxiao.cf/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HBase" scheme="luoxiao.cf/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存小结</title>
    <link href="luoxiao.cf/2019/05/13/2019-05-13-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93/"/>
    <id>luoxiao.cf/2019/05/13/2019-05-13-分布式缓存总结/</id>
    <published>2019-05-13T22:41:00.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>缓存是提高服务访问速度的最有效的途径之一，下面对缓存的基本原理以及使用做一个小结。</p><h2 id="缓存的基本原理"><a class="markdownIt-Anchor" href="#缓存的基本原理"></a> 缓存的基本原理</h2><p>缓存指将数据存储在相对较高访问速度的存储介质中，以供系统处理;缓存的本质是一个内存Hash表，数据缓存是以KV形式存储在内存的Hash表中，Hash表数据读写的时间复杂度为O(1)，可以参考下图加深理解，图片摘自-《大型网站技术架构：核心原理与案例分析》</p><p><img src="https://i.loli.net/2019/05/13/5cd984ed8ac5f82181.jpeg" alt="webwxgetmsgimg (2).jpeg"></p><p>下图为是应用到代码中时的逻辑图</p><p><img src="https://i.loli.net/2019/05/13/5cd984ed8a2e348536.jpeg" alt="webwxgetmsgimg (1).jpeg"></p><h2 id="合理使用缓存"><a class="markdownIt-Anchor" href="#合理使用缓存"></a> 合理使用缓存</h2><p>缓存虽然有很多好处，但是不合理的使用缓存反而会帮倒忙，成为系统累赘。作为一个合格的开发者，有必要搞清楚其应用点，以及在应用时的注意事项，下面对其进行简单小结。</p><ul><li>频繁修改的数据</li></ul><p>频繁修改的数据不宜存入缓存，如果你这么做了，数据在存入缓存后，应用还来不及访问，就已经再次失效了，途增系统负担。</p><ul><li>没有热点访问的数据</li></ul><p>内存往往是有限的，在往内存存储时，若 redis 检测到已经没有足够空间再容纳新增加数据时，会将长期未使用的数据清理出缓存。试想一下缓存被大量非热点数据，会是怎么样的？可能数据还没有再次被访问就已经被挤出缓存。在为数据做缓存时要遵守二八原则，大部分访问的数据没有集中在小部分数据上，那么缓存就没有意义了。</p><ul><li>数据的不一致性和脏读</li></ul><p>我们会见到某购物平台店家修改了商品，但前台并未实时更新数据，这种现象称为数据的<strong>不一致和脏读</strong>。缓存内会给数据设置过­期时间，当数据过期后会重新加载数据库数­据到缓存，所以往往会有一定延时。在互联网行业中，这种延时是可以被接受的。但假如产品人员表示非要优化，那么也有应对方案，就是做实时更新同步缓存，但这种做法会带来更多的系统开销和数据一致性问题。</p><ul><li>缓存的高可用</li></ul><p>在公司中，可能会发现对于业务场景，单台 redis 缓存服务即可满足日常需要。但随着业务不断扩展，可能就会带来很多问题。比如当 redis 服务宕机时，整个服务器的业务压力会落在数据­库服务器上。这种压力的突然飙升很有可能造成服务宕机，而且这种宕机并不是简单的直接重起服务就可以解决的。对于这种问题一些人可能会使用热备服务器去解决，当主缓存服务宕掉后，自动切换到备份缓存服务器，但是这样做 违背了缓存设计的初衷，正确的做法应该是使用<strong>分布式缓存</strong>，数据会被缓存在多台机器上，当某台机器不可用时只是部分数据不可用，重新启动即可。</p><ul><li>缓存预热</li></ul><p>缓存中存放的是热点数据，热点数据又是缓存系统利用LRU算法对不断访问的数据筛选淘汰出来的，这个过程需要花费较长的时间。新启动的缓存系统如果没有任何数据，在重建缓存数据过程中，系统的性能和数据库负载都不会太好，那么最好在缓存系统启动时就把数据加载好，这种手段叫<strong>缓存的预热</strong>。例如淘宝双十一，开发人员会提前一个月预热大量的缓存数据。</p><ul><li>缓存穿透</li></ul><p>对于访问数据库没有的数据，可能一些开发人员的做法是直接返回到前台，但是这种做法是不正确的。正确的做法应是将其<strong>key缓存起来value 设置为NULL</strong>即可。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;缓存是提高服务访问速度的最有效的途径之一，下面对缓存的基本原理以及使用做一个小结。&lt;/p&gt;&lt;h2 id=&quot;缓存
      
    
    </summary>
    
      <category term="分布式" scheme="luoxiao.cf/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Hbase ThriftServer访问内网HBase</title>
    <link href="luoxiao.cf/2019/05/10/2019-05-10-Hbase-ThriftServer%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91HBase/"/>
    <id>luoxiao.cf/2019/05/10/2019-05-10-Hbase-ThriftServer访问内网HBase/</id>
    <published>2019-05-10T17:59:00.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>本地集群环境架构结构如下图所示:</p><p><img src="https://i.loli.net/2019/05/10/5cd54df270f9f.png" alt="架构图.png"></p><p>实现thriftClient与thriftServer通信，实现访问内网HBase集群</p><p>118.166.152.33和101.118.124.111 分别为公网IP,192.168.5.2/3/4分别为内网IP</p><h3 id="域名映射"><a class="markdownIt-Anchor" href="#域名映射"></a> 域名映射</h3><p>首先我们要做的是将ThriftServer服务的通信端口9000 映射到内网中，这边映射成了公网的9000端口</p><h3 id="thrift"><a class="markdownIt-Anchor" href="#thrift"></a> thrift</h3><p>下面是Thrift的百度百科</p><blockquote><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。</p></blockquote><p>Thrift支持众多通讯协议：</p><ul><li>TBinaryProtocol – 一种简单的二进制格式，简单，但没有为空间效率而优化。比文本协议处理起来更快，但更难于调试。</li><li>TCompactProtocol – 更紧凑的二进制格式，处理起来通常同样高效。</li></ul><p>想了解更多<a href="https://baike.baidu.com/item/thrift/3879058?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>支持的传输协议有：</p><ul><li>TFramedTransport – 当使用一个非阻塞服务器时，要求使用这个传输协议。它按帧来发送数据，其中每一帧的开头是长度信息。</li><li>TSocket – 使用阻塞的套接字I/O来传输。</li></ul><p>想了解更多<a href="https://baike.baidu.com/item/thrift/3879058?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>HBase ThriftServer有下面两个参数用来指定是否使用TFramedTransport协议,默认是false这边CDH中不用开启</p><p>hbase.regionserver.thrift.framed</p><blockquote><p>Use Thrift TFramedTransport on the server side. This is the recommended transport for thrift servers and requires a similar setting on the client side. Changing this to false will select the default transport, vulnerable to DoS when malformed requests are issued due to THRIFT-601.</p></blockquote><p>hbase.regionserver.thrift.compact</p><blockquote><p>Use Thrift TCompactProtocol binary serialization protocol.</p></blockquote><p>下面参数用来配置Thrift Gateway的认证，如果你配了这个东西就必须用doAs完成认证才能完成通信</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.thrift.http<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.thrift.support.proxyuser<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true/value&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想了解更多<a href="http://hbase.apache.org/1.2/book.html" target="_blank" rel="noopener">Configure the Thrift Gateway to Use the doAs Feature</a>，看59.6章节</p><p>我这边都没有开启如下图</p><p><img src="https://i.loli.net/2019/05/10/5cd552448d4f2.png" alt="thrift.png"></p><h3 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h3><p>客户端可以用python或者是Java与ThriftServer进行通信。值得一提的是python3 在访问时会抛异常，这边初步查了一下也有解决方案，这边就先用python2.7进行测试，下面是代码示例:</p><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TBinaryProtocol</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> hbase <span class="keyword">import</span> Hbase</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to HBase Thrift server</span></span><br><span class="line">transport = TTransport.TBufferedTransport(TSocket.TSocket(<span class="string">"101.118.124.111"</span>, <span class="string">"9090"</span>))</span><br><span class="line">protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and open the client connection</span></span><br><span class="line">client = Hbase.Client(protocol)</span><br><span class="line">transport.open()</span><br><span class="line"></span><br><span class="line">rows = client.getRow(<span class="string">"cars"</span>, <span class="string">"row1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        rowKey = row.row</span><br><span class="line">        print(<span class="string">"Got row:"</span> + rowKey);</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the client connection</span></span><br><span class="line">transport.close()</span><br></pre></td></tr></table></figure><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bim.hbase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.thrift.generated.AlreadyExists;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.thrift.generated.Hbase;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.thrift.generated.ColumnDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TCompactProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TFramedTransport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseThriftTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = HbaseThriftTest.class.getClassLoader().getResourceAsStream(<span class="string">"system.properties"</span>);</span><br><span class="line">            properties.load(in);</span><br><span class="line">            host = properties.getProperty(<span class="string">"hbase.thrift.host"</span>);</span><br><span class="line">            port = Integer.parseInt(properties.getProperty(<span class="string">"hbase.thrift.port"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">        String Proto = <span class="string">"binary"</span>;</span><br><span class="line">        String TableName = <span class="string">"t1"</span>;</span><br><span class="line">        String ColFamily = <span class="string">"rowkey002"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setup the hbase thrift connection</span></span><br><span class="line">        TTransport Transport;</span><br><span class="line">        Transport = <span class="keyword">new</span> TSocket(host, port);</span><br><span class="line">        TCompactProtocol FProtocol = <span class="keyword">new</span> TCompactProtocol(Transport);</span><br><span class="line">        Hbase.Client Client = <span class="keyword">new</span> Hbase.Client(FProtocol);</span><br><span class="line">        <span class="keyword">if</span> (Proto.equals(<span class="string">"binary"</span>)) &#123;</span><br><span class="line">            TProtocol Protocol = <span class="keyword">new</span> TBinaryProtocol(Transport, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            Client = <span class="keyword">new</span> Hbase.Client(Protocol);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( Proto.equals(<span class="string">"framed"</span>)) &#123;</span><br><span class="line">            Transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(host, port));</span><br><span class="line">            TProtocol Protocol = <span class="keyword">new</span> TBinaryProtocol(Transport, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            Client = <span class="keyword">new</span> Hbase.Client(Protocol);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ! Proto.equals(<span class="string">"compact"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Protocol must be compact or framed or binary"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Transport.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prepare the column family</span></span><br><span class="line">        List&lt;ColumnDescriptor&gt; Columns = <span class="keyword">new</span> ArrayList&lt;ColumnDescriptor&gt;();</span><br><span class="line">        ColumnDescriptor col = <span class="keyword">new</span> ColumnDescriptor();</span><br><span class="line">        col.name = ByteBuffer.wrap(ColFamily.getBytes());</span><br><span class="line">        Columns.add(col);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dump existing tables</span></span><br><span class="line">        System.out.println(<span class="string">"#~ Dumping Existing tables"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ByteBuffer tn : Client.getTableNames()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-- found: "</span> + <span class="keyword">new</span> String(tn.array(), Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the new table</span></span><br><span class="line">        System.out.println(<span class="string">"#~ Creating table: "</span> + TableName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Client.createTable(ByteBuffer.wrap(TableName.getBytes()), Columns);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlreadyExists ae) &#123;</span><br><span class="line">            System.out.println(<span class="string">"WARN: "</span> + ae.message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Transport.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是system.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase.thrift.host=101.118.124.111</span><br><span class="line">hbase.thrift.port=9090</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;本地集群环境架构结构如下图所示:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/201
      
    
    </summary>
    
      <category term="大数据" scheme="luoxiao.cf/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hbase" scheme="luoxiao.cf/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的知识结构总结</title>
    <link href="luoxiao.cf/2019/05/09/2019-05-09-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <id>luoxiao.cf/2019/05/09/2019-05-09-分布式系统的知识结构总结/</id>
    <published>2019-05-09T12:47:14.000Z</published>
    <updated>2019-11-13T04:56:08.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --><p>构件分布式系统的目的是增加系统容量，提高系统可用性。转换成技术方面就是完成下面两件事</p><ul><li><p>大流量处理。所谓大流量处理就是利用集群技术将大量的并发请求分发到不同机器上</p></li><li><p>关键业务保护。提高系统可用性，所以需要将故障隔离起来，防止雪崩效应引起的整体服务无法正常服务。</p></li></ul><p>说白了就是干两件事，一是提高系统架构的吞吐量，服务更多的并发流量；二是为了提高系统的稳定性，让系统的可用性更高；下面从<strong>系统的性能</strong>和<strong>系统的稳定性</strong>来说一下在分布式下需要完成的事情。</p><h3 id="系统性能"><a class="markdownIt-Anchor" href="#系统性能"></a> 系统性能</h3><p>系统性能可以从下面五个方面入手来做整体优化，他们分别是：</p><ul><li>缓存</li><li>负载均衡</li><li>异步</li><li>数据分区</li><li>数据镜像</li></ul><h4 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h4><p>从前台到后台再到数据库，都有缓存。缓存是提高服务响应速度的最直接手段，在分布式环境中，可以使用MemCache、redis来构件分布式缓存。目前从市面上看来大家都更喜欢redis，这其中需要一个Proxy来做缓存的分片和路由。</p><h4 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h4><p>负载均衡是水平拓展的关键技术，它可以是多台机器共同分担一部分流量请求。</p><h4 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h4><p>异步这块主要是通过异步队列对请求做排队处理，这边有很多业务场景，比如可以把前端并发请求的峰值给“削平”了，让后端通过自己能够处理的速度来处理请求，进而来增加系统的吞吐量，但这通常比较适用于实时性不是很高的场景；引入消息队列后，可能会出现消息丢失的问题，这就被迫我们不得不去做消息的持久化，持久化会造成有“状态”的节点，从而增加服务调度的难度。</p><h4 id="数据分区镜像"><a class="markdownIt-Anchor" href="#数据分区镜像"></a> 数据分区/镜像</h4><p>数据分区和数据镜像可以放在一起，数据分区就是将数据按照某种固定的方式分成多个区。比如按照地区来分，这样需要一个数据路由的中间件，不同地区来访问不同区域的数据库，来减少数据库的压力。但是这样会造成跨库的join和跨库的事务异常复杂。而数据镜像是将数据复制成多分，这样就不需要数据中间件了，可以在任意节点上进行读写， 内部会进行自动数据同步，但是数据镜像中最大的问题就是数据一致性问题。</p><p>对于一般公司来说，在初期会使用读写分离的数据镜像方式，然而后期会采用分库分表的方式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 05:23:54 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;构件分布式系统的目的是增加系统容量，提高系统可用性。转换成技术方面就是完成下面两件事&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="分布式" scheme="luoxiao.cf/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
